package ats.algo.core.comparetomarket;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import ats.algo.core.MarketGroup;
import ats.algo.core.baseclasses.MatchParam;
import ats.algo.core.baseclasses.MatchParams;
import ats.algo.core.baseclasses.MatchParams.ParamArray;
import ats.algo.core.markets.Market;
import ats.algo.core.markets.MarketCategory;
import ats.algo.core.markets.Markets;
import ats.algo.genericsupportfunctions.GCMath;
import ats.algo.genericsupportfunctions.Gaussian;
import ats.algo.genericsupportfunctions.Minimiser;
import ats.algo.genericsupportfunctions.Minimiser.FunctionToMinimise;
import ats.algo.genericsupportfunctions.Minimiser.MinimiserResults;
import ats.algo.matchengineframework.MatchEngine;
import ats.core.AtsBean;

/**
 * calculates the set of parameters that best fit the supplied set of markets
 *
 * @author Geoff
 *
 */
public class ParamFinder extends AtsBean {

    private static final boolean DEBUG_ON = false; // set to true for detailed
                                                   // logging

    private MatchEngine matchEngine;
    private MatchParams matchParams;
    private MarketPricesList marketPricesList;
    private Map<String, Map<String, MarketProbs>> matchedMarkets;
    private Collection<MarketGroup> marketGroups;

    /**
     *
     * @param matchEngine already initialised instance of the matchEngine to be used for price calculation
     */
    public ParamFinder(MatchEngine matchEngine) {
        this.matchEngine = matchEngine;
    }

    /**
     *
     * @param matchParams the matchParameters to be used as the starting point for the param finding algorithm
     */
    public void setMatchParameters(MatchParams matchParams) {
        this.matchParams = matchParams;
    }

    /**
     * return the best fit matchParams, following calculate();
     *
     * @return
     */
    public MatchParams getMatchParams() {
        return matchParams;
    }

    /**
     * provides a single set of market prices to be used in the param finding process can't be used as well as
     * setMarketPricesList - use one or the other.
     *
     * @param marketPrices
     */
    public void setMarketPrices(MarketPrices marketPrices) {
        /*
         * create a list containing just one element
         */
        marketPricesList = new MarketPricesList();
        marketPricesList.put("Default", marketPrices);
    }

    /**
     * provides a collection of market prices to be used in the param finding process, each from a different source and
     * containing weightings that will be used by the param finder
     *
     * @param marketPricesList
     */
    public void setMarketPricesList(MarketPricesList marketPricesList) {
        this.marketPricesList = marketPricesList;
    }

    /**
     * defines the cost function that will be minimised to find the params
     *
     * @param paramMap
     * @return
     */
    double costFunction(double[] x) {
        matchParams.setFromArray(x);
        matchEngine.setMatchParams(matchParams);
        if (DEBUG_ON) {
            debug("Cost function input: " + matchParams);
        }
        matchEngine.calculate();

        Markets markets = matchEngine.getCalculatedMarkets();
        CompareToMarketMetrics metrics = CompareToMarket.calculateCostMetrics(markets, matchedMarkets);
        double cost = metrics.getMarketsCost() - metrics.getMinPossibleCost();
        if (DEBUG_ON) {
            debug("Cost function output: %.4f\n\n", cost);
        }
        return cost;
    }

    /**
     * main param finding method. this takes the already supplied objects (MatchEngine, MatchParams, MatchState,
     * MarketPrices) and finds the set of parameters which best fit the supplied prices
     *
     *
     *
     * @return
     */
    public ParamFindResults calculate() {
        /*
         * don't want to use the bias during the param finding process
         */
        MatchParams initialMatchParams = matchParams.copy();
        matchParams.setApplyBias(false);
        /*
         * start by calculating the set of markets generated by the supplied params
         */

        matchEngine.setMatchParams(matchParams);
        matchEngine.calculate();
        Markets markets = matchEngine.getCalculatedMarkets();

        MarketPricesStatus statusAtStart = CompareToMarket.getMarketPricesStatus(markets, marketPricesList);
        for (String warningMsg : statusAtStart.getWarningMessages())
            warn(warningMsg);
        info("Input marketPrices ok: %b,  nSources: %d, nMarkets: %d, starting cost: %.3f, min possible cost: %.3f, paramFindReqd: %b,",
                        statusAtStart.isPricesOk(), statusAtStart.getnSources(), statusAtStart.getnMarkets(),
                        statusAtStart.getActualCostForOurMarkets(),
                        statusAtStart.getMinCostPossibleWithTheseMarketsPrices(), statusAtStart.isParamFindRequired());
        /*
         * create the results object
         */
        ParamFindResults results = new ParamFindResults();
        results.setnIterations(0);
        if (!statusAtStart.isPricesOk()) {
            for (String s : statusAtStart.getWarningMessages())
                warn(s);
            results.addResultSummaryInfo(false, ParamFindResultsStatus.RED, statusAtStart.toStringWarningMessages());
            results.setMinFunctionValueAchievable(statusAtStart.getMinCostPossibleWithTheseMarketsPrices());
            return results;
        }
        /*
         * check minAchievable within thresholds
         */
        double minCostAchievable = GCMath.round(statusAtStart.getMinCostPossibleWithTheseMarketsPrices(),
                        ParamFindResults.PF_DECIMAL_PLACES);
        Map<String, Map<String, Map<String, CompareToMarketMetricsItemInfo>>> infoAtStart =
                        statusAtStart.getCompareToMarketMetrics().getMarketsCostDescriptionInfo();
        if (minCostAchievable > CompareToMarket.getRedAlertThreshold()) {
            String summaryText = String.format(
                            "Inconsistent inputs, check prices against market. Param find not attempted.  Cost metric: %.3f.  Min achievable cost %.3f",
                            statusAtStart.getActualCostForOurMarkets(),
                            statusAtStart.getMinCostPossibleWithTheseMarketsPrices());

            results.addResultSummaryInfo(false, ParamFindResultsStatus.RED, summaryText);
            results.addResultDetailRows(infoAtStart);
            return results;
        }
        /*
         * check whether param find needed
         */
        double costMetric =
                        GCMath.round(statusAtStart.getActualCostForOurMarkets(), ParamFindResults.PF_DECIMAL_PLACES);
        if (costMetric - minCostAchievable < CompareToMarket.getParamFindKickoffThreshold()) {
            String summaryText = String.format("No param find necessary.  Cost metric: %.3f.  Min achievable cost %.3f",
                            statusAtStart.getActualCostForOurMarkets(),
                            statusAtStart.getMinCostPossibleWithTheseMarketsPrices());
            results.addResultSummaryInfo(true, ParamFindResultsStatus.GREEN, summaryText);
            results.addResultDetailRows(infoAtStart);
            return results;
        }

        /*
         * Param find IS going to happen look through all the supplied marketPrices and create the list of
         * matchedMarkets where we can relate prices we can calculate to supplied prices
         */
        MarketPricesStatus marketPricesStatus = new MarketPricesStatus();
        matchedMarkets = CompareToMarket.getMatchedMarkets(markets, marketPricesList, marketPricesStatus);
        if (matchedMarkets.size() == 0) {
            String summaryText = String.format("No matched markets to param find against", 0, 0);
            results.addResultSummaryInfo(true, ParamFindResultsStatus.RED, summaryText);
            return results;
        } else {
            if (!marketPricesStatus.isPricesOk())
                for (String s : statusAtStart.getWarningMessages())
                    warn(s);
            for (Entry<String, Map<String, MarketProbs>> e : matchedMarkets.entrySet()) {
                for (Entry<String, MarketProbs> e2 : e.getValue().entrySet()) {
                    String source = e2.getKey();
                    MarketProbs marketProbs = e2.getValue();
                    String type = marketProbs.getMarketType();
                    String seqId = marketProbs.getMarketSequenceId();
                    String lineId = marketProbs.getLineId();
                    Market market = markets.get(type, seqId);
                    if ((market.getCategory() != MarketCategory.GENERAL) && !(market.getLineId().equals(lineId))) {
                        String ahcpLineId = marketProbs.getLineId();
                        /*
                         * Updated the AHCP line to match sprd market
                         */
                        if (market.getFullKey().contains("AHCP")) {

                            String sequenceId = market.getSequenceId();
                            String score;
                            if (sequenceId.contains("H"))
                                score = sequenceId.substring(2, sequenceId.length());
                            else
                                score = sequenceId.substring(1, sequenceId.length());
                            String[] index = score.split("-");
                            int ahcp = Integer.parseInt(index[0]) - Integer.parseInt(index[1]);
                            Double ahcpD = Double.parseDouble(ahcpLineId);
                            ahcpD -= ahcp;
                            ahcpLineId = String.valueOf(ahcpD);
                        }
                        /*
                         * the line nos are different for an OVUN or HCAP mkt so get the right line
                         */
                        market = market.getMarketForLineId(ahcpLineId);
                    }
                    for (Entry<String, Double> e3 : marketProbs.getProbs().entrySet()) {
                        String selectionName = e3.getKey();
                        info("Input price.  Type: %s, source: %s, seqId: %s, lineId: %s, selection: %s, mktProb: %.3f, ourProb: %.3f",
                                        type, source, seqId, lineId, selectionName, e3.getValue(),
                                        market.getSelectionsProbs().get(selectionName));
                    }
                }
            }
        }

        /*
         * Generate the set of marketGroups on which to do a param find
         */
        CompareToMarketMetrics costMetrics = CompareToMarket.calculateCostMetrics(markets, matchedMarkets);
        Map<MarketGroup, GroupMetrics> groupMetricsMap = costMetrics.getGroupMetricsMap();
        marketGroups = new ArrayList<MarketGroup>();
        boolean marketForUnspecifiedGroup = false;
        for (MarketGroup marketGroup : groupMetricsMap.keySet()) {
            if (marketGroup == MarketGroup.NOT_SPECIFIED)
                marketForUnspecifiedGroup = true;
            else
                marketGroups.add(marketGroup);
        }
        /*
         * set marketGroups to null if any of the supplied markets do not have a market group specified - need to param
         * find on all params in that case
         */
        if (marketForUnspecifiedGroup)
            marketGroups = null;
        /*
         * matchedMarkets contains at least one market to match on
         */
        results.setMinFunctionValueAchievable(GCMath.round(statusAtStart.getMinCostPossibleWithTheseMarketsPrices(),
                        ParamFindResults.PF_DECIMAL_PLACES));
        /*
         * do any sport specific param finding or pre-processing of matchParams
         */
        Set<MarketGroup> marketGroupsPreProcessed = matchEngine.preprocessParamFind(matchParams, marketPricesList);
        /*
         * remove from the marketGroups and matchedMarkets any that have been pre-processed
         */

        if (marketGroupsPreProcessed != null && marketGroups != null) {
            marketGroups.removeAll(marketGroupsPreProcessed);
            removePreProcessedMarketGroupsFromMatchedMarkets(matchedMarkets, marketGroupsPreProcessed);
        }

        boolean pfSuccess;
        double fnValueAtMinimum;
        int nIterations;
        if (marketGroupsPreProcessed != null && matchedMarkets.size() == 0) {
            /*
             * the preprocessing has done all the necessary param finding so return success
             */
            pfSuccess = true;
            fnValueAtMinimum = 0.0;
            nIterations = 0;
        } else {
            /*
             * proceed with the generic param find on those params not dealt with via pre-processing
             */
            for (MatchParam matchParam : matchParams.getParamMap().values()) {
                /*
                 * don't let the param find start too close to the allowed min,max values so adjust the param value
                 * where necessary, taking care only to adjust params which are actually going to be changed during the
                 * param finding process
                 */
                Gaussian g = matchParam.getGaussian();
                if (MatchParams.inMarketGroups(marketGroups, matchParam) && g.getStdDevn() > 0) {
                    double min = matchParam.getMinAllowedParamValue();
                    double max = matchParam.getMaxAllowedParamValue();
                    double delta = (max - min) / 10.0;
                    double pfMin = min + delta;
                    double pfMax = max - delta;
                    double value = g.getMean();
                    if (value < pfMin)
                        g.setMean(pfMin);
                    if (value > pfMax)
                        g.setMean(pfMax);
                }
            }
            ParamArray paramArray = matchParams.getAsArray(marketGroups, matchEngine.isParamFindStdDevns(), false);
            if (paramArray.size() == 0) {
                String summaryText = String.format(
                                "No overlap between marketGroups specified for supplied marketPrices and marketGroups specified for MatchParams, so nothing to param find against",
                                statusAtStart.getActualCostForOurMarkets(),
                                statusAtStart.getMinCostPossibleWithTheseMarketsPrices());
                results.addResultSummaryInfo(true, ParamFindResultsStatus.RED, summaryText);
                return results;
            }

            FunctionToMinimise fn = (double[] z) -> costFunction(z);
            Minimiser minimiser = new Minimiser();
            minimiser.setLogIterations(true);
            minimiser.setDetailedLogRequired(marketPricesList.isGenerateDetailedParamFindLog());
            info("Starting param find to find best values for %d params", paramArray.size());
            MinimiserResults minimiserResults = minimiser.minimise(paramArray.x, paramArray.delta, 0.005, fn);
            results.setDetailedLog(minimiserResults.detailedLog);
            matchParams.setFromArray(minimiserResults.bestX);
            fnValueAtMinimum =
                            GCMath.round(minimiserResults.functionValueAtMinimum, ParamFindResults.PF_DECIMAL_PLACES);
            pfSuccess = minimiserResults.success && (fnValueAtMinimum < CompareToMarket.getAmberAlertThreshold());
            nIterations = minimiserResults.nIterations;
            results.setAxisRotationReqd(false);
            if (!pfSuccess) {
                /*
                 * retry the param find rotating the axes
                 */
                info("Cost above amber threshold.  Trying again with axis rotation");
                paramArray = matchParams.getAsArray(marketGroups, matchEngine.isParamFindStdDevns(), true);
                minimiserResults = minimiser.minimise(paramArray.x, paramArray.delta, 0.005, fn);
                fnValueAtMinimum = GCMath.round(minimiserResults.functionValueAtMinimum,
                                ParamFindResults.PF_DECIMAL_PLACES);
                pfSuccess = minimiserResults.success && (fnValueAtMinimum < CompareToMarket.getAmberAlertThreshold());
                nIterations += minimiserResults.nIterations;
                results.setAxisRotationReqd(true);
                matchParams.setFromArray(minimiserResults.bestX);
            }

            if (!minimiserResults.success) {
                info("Param finding failed due to Minimiser reporting failure to converge to a result");
                pfSuccess = false;
            } else if (fnValueAtMinimum > CompareToMarket.getRedAlertThreshold()) {
                info("Param finder did not find satisfactory solution.  Cost still exceeds red threshold");
                pfSuccess = false;
            } else
                pfSuccess = true;

            pfSuccess = minimiserResults.success && (fnValueAtMinimum < CompareToMarket.getRedAlertThreshold());
        }
        if (!pfSuccess) {
            /*
             * restore matchParams to their starting values
             */
            matchParams = initialMatchParams;
        }
        results.setFunctionValueAtMinimum(fnValueAtMinimum);
        results.setnIterations(nIterations);
        matchParams.roundParamValues();
        /*
         * generate the results description
         */
        matchParams.setApplyBias(false);
        matchEngine.setMatchParams(matchParams);
        matchEngine.calculate();
        Markets newMarkets = matchEngine.getCalculatedMarkets();
        MarketPricesStatus statusAtEnd = CompareToMarket.getMarketPricesStatus(newMarkets, marketPricesList);

        Boolean sourceDataOk = GCMath.round(results.getMinFunctionValueAchievable(),
                        ParamFindResults.PF_DECIMAL_PLACES) < CompareToMarket.getAmberAlertThreshold();
        double costMetricAtStart =
                        GCMath.round(statusAtStart.getActualCostForOurMarkets(), ParamFindResults.PF_DECIMAL_PLACES);
        double costMetricAtEnd =
                        GCMath.round(statusAtEnd.getActualCostForOurMarkets(), ParamFindResults.PF_DECIMAL_PLACES);

        Map<String, Map<String, Map<String, CompareToMarketMetricsItemInfo>>> infoAtEnd =
                        statusAtEnd.getCompareToMarketMetrics().getMarketsCostDescriptionInfo();
        results.updateParamFindResultsForMetrics(minCostAchievable, sourceDataOk, costMetricAtStart, costMetricAtEnd,
                        infoAtStart, infoAtEnd);
        info(results.getTraderParamFindResultsDescription().getResultSummary());
        return results;
    }

    private void removePreProcessedMarketGroupsFromMatchedMarkets(Map<String, Map<String, MarketProbs>> matchedMarkets,
                    Set<MarketGroup> marketGroupsPreProcessed) {
        Set<String> outerKeysToRemove = new HashSet<>();
        for (Entry<String, Map<String, MarketProbs>> e : matchedMarkets.entrySet()) {
            String outerKey = e.getKey();
            Map<String, MarketProbs> innerMap = e.getValue();
            Set<String> innerKeysToRemove = new HashSet<>();
            for (Entry<String, MarketProbs> e2 : innerMap.entrySet()) {
                if (marketGroupsPreProcessed.contains(e2.getValue().getMarketGroup()))
                    innerKeysToRemove.add(e2.getKey());
            }
            for (String innerKey : innerKeysToRemove)
                innerMap.remove(innerKey);
            if (innerMap.size() == 0)
                outerKeysToRemove.add(outerKey);
        }
        for (String outerKey : outerKeysToRemove)
            matchedMarkets.remove(outerKey);
    }

}
