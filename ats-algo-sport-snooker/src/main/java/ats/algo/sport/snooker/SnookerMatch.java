package ats.algo.sport.snooker;

import ats.algo.core.common.TeamId;
import ats.algo.genericsupportfunctions.RandomNoGenerator;
import ats.algo.sport.snooker.SnookerMatchIncident.SnookerMatchIncidentType;
import ats.algo.sport.snooker.SnookerMatchIncidentResult.SnookerMatchIncidentResultType;
import ats.algo.montecarloframework.MonteCarloMatch;

public class SnookerMatch extends MonteCarloMatch {

    /**
     * Container to hold any data generated by a single run of the Match which is not contained in MatchState and is
     * needed to generate the required statistics. eg. who won the current leg.
     * 
     * @author Robert
     * 
     */
    class SnookerMatchFacts {

        TeamId frameWinnerCurrentIsA;
        TeamId frameWinnerNextIsA;
        boolean frame4WinnerIsA;
        boolean matchWinnerisA;
        boolean pointWinnerPlusTwoiSA;
        boolean pointWinnerNextisA;
        boolean pointWinnerNextPlusisA;
        boolean frameWinnerNPlus2IsA;
        boolean frameNextIsPlayed;
        boolean frameNPlus2IsPlayed;
        volatile int pointsA;
        volatile int pointsB;
        int framesA;
        int framesB;

        void reset() {
            frameNextIsPlayed = false;
            frameNPlus2IsPlayed = false;
            frameWinnerCurrentIsA = TeamId.UNKNOWN;
            frameWinnerNextIsA = TeamId.UNKNOWN;
            frame4WinnerIsA = false;
            pointWinnerNextisA = false;
            pointWinnerPlusTwoiSA = false;

            pointsA = 0;
            pointsB = 0;
            framesA = 0;
            framesB = 0;

        }
    }

    private SnookerMatchState simulationMatchState;
    private SnookerMatchFacts matchFacts;

    public SnookerMatch(SnookerMatchFormat matchFormat, SnookerMatchState matchState, SnookerMatchParams matchParams) {

        super(matchFormat, matchState, matchParams);
        monteCarloMarkets = new SnookerMatchMarketsFactory(matchState);
        this.simulationMatchState = (SnookerMatchState) matchState.copy();
        /*
         * create the container for holding match facts just once rather than every time playMatch is executed - greatly
         * improves performance
         */
        this.matchFacts = new SnookerMatchFacts();
    }

    @Override
    public MonteCarloMatch clone() {
        return new SnookerMatch((SnookerMatchFormat) matchFormat, (SnookerMatchState) matchState,
                        (SnookerMatchParams) matchParams);
    }

    @Override
    public void playMatch() {

        simulationMatchState.setEqualTo(matchState);
        int raceNo = simulationMatchState.getRace();
        int startFrameNo = simulationMatchState.getFramesA() + simulationMatchState.getFramesB() + 1;
        int currentPointNoA = simulationMatchState.getFramesA();
        int currentPointNoB = simulationMatchState.getFramesB();
        int timesRace = Math.max(currentPointNoA, currentPointNoB) / raceNo + 1;
        if (simulationMatchState.getServe() == TeamId.UNKNOWN)
            if (RandomNoGenerator.nextBool()) {
                simulationMatchState.setServeInFirstSet(TeamId.A);
                simulationMatchState.setServe(TeamId.A);
            } else {
                simulationMatchState.setServeInFirstSet(TeamId.B);
                simulationMatchState.setServe(TeamId.B);
            }
        /*
         * draw the prob of A winning leg as a random variable drawn from the gaussian distribution for the parameter
         * probAWinsLeg
         */
        double pa = ((SnookerMatchParams) matchParams).getOnFramePctA().nextRandom();
        double currentPa = ((SnookerMatchParams) matchParams).getOnCurrentFramePctA().nextRandom();
        SnookerMatchIncidentResult matchEventResult;
        matchFacts.reset();
        do {
            double r = RandomNoGenerator.nextDouble();

            boolean frameWonByA;
            int currentFrameNo = simulationMatchState.getFramesA() + simulationMatchState.getFramesB() + 1;
            if (currentFrameNo == startFrameNo) {
                frameWonByA = r < currentPa;
            } else {
                frameWonByA = r < pa;
            }

            if (frameWonByA) {
                SnookerMatchIncident snookerMatchIncident = new SnookerMatchIncident();
                snookerMatchIncident.set(SnookerMatchIncidentType.FRAMEWON);
                snookerMatchIncident.setTeamId(TeamId.A);
                matchEventResult = (SnookerMatchIncidentResult) simulationMatchState
                                .updateStateForIncident(snookerMatchIncident, false);
            } else {
                SnookerMatchIncident snookerMatchIncident = new SnookerMatchIncident();
                snookerMatchIncident.set(SnookerMatchIncidentType.FRAMEWON);
                snookerMatchIncident.setTeamId(TeamId.B);
                matchEventResult = (SnookerMatchIncidentResult) simulationMatchState
                                .updateStateForIncident(snookerMatchIncident, false);
            }
            TeamId teamId = matchEventResult.getTeamId();
            switch (matchEventResult.getSnookerMatchIncidentResultType()) {
                case FRAMEWON:
                    if (TeamId.A == teamId) {
                        if (currentFrameNo == startFrameNo)
                            matchFacts.frameWinnerCurrentIsA = TeamId.A;
                        if (currentFrameNo == startFrameNo + 1)
                            matchFacts.frameWinnerNextIsA = TeamId.A;
                        if (simulationMatchState.getFramesA() == raceNo * timesRace
                                        && simulationMatchState.getFramesB() < raceNo * timesRace)
                            matchFacts.frame4WinnerIsA = true;
                    } else {
                        if (currentFrameNo == startFrameNo)
                            matchFacts.frameWinnerCurrentIsA = TeamId.B;
                        if (currentFrameNo == startFrameNo + 1)
                            matchFacts.frameWinnerNextIsA = TeamId.B;
                        if (simulationMatchState.getFramesB() == raceNo * timesRace
                                        && simulationMatchState.getFramesA() < raceNo * timesRace)
                            matchFacts.frame4WinnerIsA = false;
                    }
                    break;
                case MATCHWON:
                    if (TeamId.A == teamId) {
                        if (currentFrameNo == startFrameNo)
                            matchFacts.frameWinnerCurrentIsA = TeamId.A;
                        if (currentFrameNo == startFrameNo + 1)
                            matchFacts.frameWinnerNextIsA = TeamId.A;
                        if (simulationMatchState.getFramesA() == raceNo * timesRace
                                        && simulationMatchState.getFramesB() < raceNo * timesRace)
                            matchFacts.frame4WinnerIsA = true;
                        matchFacts.matchWinnerisA = true;
                    } else {
                        matchFacts.matchWinnerisA = false;
                        if (currentFrameNo == startFrameNo)
                            matchFacts.frameWinnerCurrentIsA = TeamId.B;
                        if (currentFrameNo == startFrameNo + 1)
                            matchFacts.frameWinnerNextIsA = TeamId.B;
                        if (simulationMatchState.getFramesB() == raceNo * timesRace
                                        && simulationMatchState.getFramesA() < raceNo * timesRace)
                            matchFacts.frame4WinnerIsA = false;
                    }
                    break;
                default:
                    break;
            }

        } while ((matchEventResult.getSnookerMatchIncidentResultType() != SnookerMatchIncidentResultType.DRAW)
                        && (matchEventResult
                                        .getSnookerMatchIncidentResultType() != SnookerMatchIncidentResultType.MATCHWON));
        ((SnookerMatchMarketsFactory) monteCarloMarkets).updateStats(simulationMatchState, matchFacts);
    }

    @Override
    public void consolidateStats(MonteCarloMatch match) {
        this.monteCarloMarkets.consolidate(((SnookerMatch) match).monteCarloMarkets);
    }

    @Override
    public void resetStatistics() {
        monteCarloMarkets = new SnookerMatchMarketsFactory((SnookerMatchState) matchState);

    }

}
