package ats.algo.sport.examplesport;

import ats.algo.core.baseclasses.MatchFormat;
import ats.algo.core.baseclasses.MatchParams;
import ats.algo.core.baseclasses.MatchState;
import ats.algo.genericsupportfunctions.RandomNoGenerator;
import ats.algo.montecarloframework.MonteCarloMatch;
import ats.algo.sport.examplesport.ExampleMatchIncident.ExampleMatchIncidentType;

public class ExampleMatch extends MonteCarloMatch {

    /**
     * Container to hold any data generated by a single run of the Match which is not contained in MatchState and is
     * needed to generate the required statistics. eg. who won the current leg.
     * 
     * @author Geoff
     * 
     */
    class ExampleMatchFacts {

        boolean legWinnerCurrentIsA;
        boolean legWinnerNextIsA;
        boolean legWinnerNPlus2IsA;
        boolean legNextIsPlayed;
        boolean legNPlus2IsPlayed;

        void reset() {
            legNextIsPlayed = false;
            legNPlus2IsPlayed = false;
        }
    }

    private ExampleMatchState simulationMatchState;
    private ExampleMatchFacts matchFacts;
    private ExampleMatchIncident matchIncident;

    public ExampleMatch(ExampleMatchFormat matchFormat, ExampleMatchState matchState, ExampleMatchParams matchParams) {

        super((MatchFormat) matchFormat, (MatchState) matchState, (MatchParams) matchParams);
        monteCarloMarkets = new ExampleMatchMarketsFactory(matchFormat.getNoLegsInMatch());
        this.simulationMatchState = (ExampleMatchState) matchState.copy();
        /*
         * create the container for holding match facts just once rather than every time playMatch is executed - greatly
         * improves performance
         */
        this.matchFacts = new ExampleMatchFacts();
        this.matchIncident = new ExampleMatchIncident();
    }

    @Override
    public MonteCarloMatch clone() {
        ExampleMatch cc = new ExampleMatch((ExampleMatchFormat) matchFormat, (ExampleMatchState) matchState,
                        (ExampleMatchParams) matchParams);
        return cc;
    }

    @Override
    public void playMatch() {
        simulationMatchState.setEqualTo(matchState);

        /*
         * draw the prob of A winning leg as a random variable drawn from the gaussian distribution for the parameter
         * probAWinsLeg
         */

        double p = ((ExampleMatchParams) matchParams).getProbAWinsLeg().getGaussian().nextRandom();

        ExampleMatchIncidentResult matchEventResult;
        int legNoRelativeToStart = 0;
        matchFacts.reset();
        do {
            double r = RandomNoGenerator.nextDouble();
            boolean legWonByA = r < p;
            if (legWonByA) {
                matchIncident.setExampleMatchIncidentType(ExampleMatchIncidentType.LEGWONBYA);
            } else {
                matchIncident.setExampleMatchIncidentType(ExampleMatchIncidentType.LEGWONBYB);
            }
            matchEventResult = (ExampleMatchIncidentResult) simulationMatchState.updateStateForIncident(matchIncident,
                            false);
            switch (legNoRelativeToStart) {

                case 0:
                    matchFacts.legWinnerCurrentIsA = legWonByA;
                    break;
                case 1:
                    matchFacts.legNextIsPlayed = true;
                    matchFacts.legWinnerNextIsA = legWonByA;
                    break;
                case 2:
                    matchFacts.legNPlus2IsPlayed = true;
                    matchFacts.legWinnerNPlus2IsA = legWonByA;
                    break;
                default:
                    /*
                     * do nothing - only collecting stats for first three legs
                     */
                    break;
            }
            legNoRelativeToStart++;

        } while ((matchEventResult != ExampleMatchIncidentResult.DRAW)
                        && (matchEventResult != ExampleMatchIncidentResult.MATCHWONBYA)
                        && (matchEventResult != ExampleMatchIncidentResult.MATCHWONBYB));
        ((ExampleMatchMarketsFactory) monteCarloMarkets).updateStats(simulationMatchState, matchFacts);
    }

    @Override
    public void consolidateStats(MonteCarloMatch match) {
        this.monteCarloMarkets.consolidate(((ExampleMatch) match).monteCarloMarkets);
    }

    @Override
    public void resetStatistics() {
        monteCarloMarkets.reset();

    }

}
