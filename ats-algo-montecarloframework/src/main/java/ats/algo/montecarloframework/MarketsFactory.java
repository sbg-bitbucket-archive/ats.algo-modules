package ats.algo.montecarloframework;

import java.util.ArrayList;
import java.util.List;

import ats.algo.core.MarketGroup;
import ats.algo.core.baseclasses.MatchParams;
import ats.algo.core.baseclasses.MatchState;
import ats.algo.core.common.TeamId;
import ats.algo.core.markets.Market;
import ats.algo.core.markets.MarketCategory;
import ats.algo.core.markets.Markets;
import ats.algo.genericsupportfunctions.GCMath;

/**
 * Base class used for holding statistics generated by the multiple model runs and for generating the various types of
 * market
 * 
 * @author Geoff
 * 
 */
public abstract class MarketsFactory {

    private List<Statistic> statistics;
    private boolean allowGenerateAllSelection = true;
    private boolean correctScoreDisplayHasTeamId = false;
    private double correctScoreLimit = 0.002;
    private int simulationLimit = 0;

    private static final int PROBS_DECIMAL_PLACES = 5;

    public void setAllowGenerateAllSelection(boolean allowGenerateAllSelection) {
        this.allowGenerateAllSelection = allowGenerateAllSelection;
    }

    /**
     * @param correctScoreDisplayHasTeamId the correctScoreDisplayHasTeamId to set
     */
    public void setCorrectScoreDisplayHasTeamId(boolean correctScoreDisplayHasTeamId) {
        this.correctScoreDisplayHasTeamId = correctScoreDisplayHasTeamId;
    }

    public void setSimulationLimit(int simulationLimit) {
        this.simulationLimit = simulationLimit;
    }

    public void setCorrectScoreLimit(double correctScoreLimit) {
        this.correctScoreLimit = correctScoreLimit;
    }

    public MarketsFactory() {
        statistics = new ArrayList<Statistic>();
    }

    /**
     * generate the set of markets associated with these statistics
     */
    public Markets generateMonteCarloMarkets() {
        Markets markets = new Markets();
        for (Statistic statistic : statistics) {
            Market market = statistic.generateMarket();
            if (market != null)
                markets.addMarketWithShortKey(market);
        }
        return markets;
    }

    /**
     * 
     */
    /**
     * consolidate all the stats from the target into this instance. Used when calcs spread over multiple threads to
     * consolidate the collected data into one instance of the class
     * 
     * @param fromInstance
     */
    public void consolidate(MarketsFactory fromInstance) {
        for (int i = 0; i < statistics.size(); i++) {
            Statistic statistic = statistics.get(i);
            statistic.consolidate(fromInstance.get(i));
        }
    }

    private Statistic get(int i) {
        return statistics.get(i);
    }

    /**
     * resets all the stats - used before starting a recalculation of probabilities
     */
    public void reset() {
        for (Statistic statistic : statistics) {
            statistic.reset();
        }
    }

    /**
     * Defines the general properties that all statistics must support
     * 
     * @author Geoff
     * 
     */
    public abstract class Statistic {

        protected String description;
        protected String key;
        protected String sequenceId;
        protected MarketGroup marketGroup;
        boolean isValidGivenMatchState;

        /**
         * 
         * @param key market key
         * @param description market description
         * @param marketGroup the group to which this market belongs
         * @param isValidGivenMatchState set to false if market should not be generated
         * @param sequenceId unique sequence id for this market
         */
        public Statistic(String key, String description, MarketGroup marketGroup, Boolean isValidGivenMatchState,
                        String sequenceId) {
            this.key = key;
            this.description = description;
            this.isValidGivenMatchState = isValidGivenMatchState;
            this.sequenceId = sequenceId;
            this.marketGroup = marketGroup;
            statistics.add(this);
        }

        /**
         * generates the Market associated with this statistic.
         * 
         * @return
         */
        public abstract Market generateMarket();

        /**
         * consolidates the stats into this instance from another statistic of the same type
         * 
         * @param statistic
         */
        public abstract void consolidate(Statistic statistic);

        /**
         * resets any accumulated counts
         */
        public abstract void reset();
    }

    /**
     * Holds a simple A/B or Yes/No statistic
     * 
     * @author Geoff
     * 
     */
    public class TwoWayStatistic extends Statistic {

        int countIfTrue;
        private int countIfFalse;

        protected int getCountIfTrue() {
            return countIfTrue;
        }

        protected int getCountIfFalse() {
            return countIfFalse;
        }

        private String selectionTrue;
        private String selectionFalse;

        /**
         * Holds a statistic with just two outcomes, usually "A"/"B" or "Yes"/"No" - e.g. match winner
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * 
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionTrue
         * @param selectionFalse
         */
        public TwoWayStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        String selectionTrue, String selectionFalse) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.selectionTrue = selectionTrue;
            this.selectionFalse = selectionFalse;
            reset();
        }

        /**
         * Holds a statistic with just two outcomes, usually "A"/"B" or "Yes"/"No" - e.g. match winner
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionTrue
         * @param selectionFalse
         */
        public TwoWayStatistic(String key, String description, MarketGroup marketGroup, Boolean isValidGivenMatchState,
                        String sequenceId, String selectionTrue, String selectionFalse) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.selectionTrue = selectionTrue;
            this.selectionFalse = selectionFalse;
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(boolean isTrue) {

            if (isTrue)
                countIfTrue++;
            else
                countIfFalse++;
        }

        @Override
        public Market generateMarket() {
            /*
             * don't generate market if it was flagged as being not wanted given match state e.g. some pre-match only or
             * in-play only
             */
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);

            market.setLineId("");
            int n = countIfTrue + countIfFalse;
            market.setIsValid(n > 0);
            if (market.isValid()) {
                double prob = GCMath.round(((double) countIfTrue) / n, PROBS_DECIMAL_PLACES);
                market.put(selectionTrue, prob);
                market.put(selectionFalse, 1 - prob);
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            countIfTrue += ((TwoWayStatistic) statistic).getCountIfTrue();
            countIfFalse += ((TwoWayStatistic) statistic).getCountIfFalse();
        }

        @Override
        public void reset() {
            countIfTrue = 0;
            countIfFalse = 0;
        }
    }

    /**
     * Holds a simple A/B or Yes/No statistic, this class is different from two way statistic as total prob is not
     * summed up to 1.
     * 
     * @author Jin
     * 
     */
    public class TwoWayPlusStatistic extends Statistic {

        int countIfTrue;
        private int countIfFalse;
        int countAll;

        protected int getCountIfTrue() {
            return countIfTrue;
        }

        protected int getCountIfFalse() {
            return countIfFalse;
        }

        protected int getCountAll() {
            return countAll;
        }

        private String selectionTrue;
        private String selectionFalse;

        /**
         * Holds a statistic with just two outcomes, usually "A"/"B" or "Yes"/"No" - e.g. match winner
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * 
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionTrue
         * @param selectionFalse
         */
        public TwoWayPlusStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        String selectionTrue, String selectionFalse) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.selectionTrue = selectionTrue;
            this.selectionFalse = selectionFalse;
            reset();
        }

        /**
         * Holds a statistic with just two outcomes, usually "A"/"B" or "Yes"/"No" - e.g. match winner
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionTrue
         * @param selectionFalse
         */
        public TwoWayPlusStatistic(String key, String description, MarketGroup marketGroup,
                        Boolean isValidGivenMatchState, String sequenceId, String selectionTrue,
                        String selectionFalse) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.selectionTrue = selectionTrue;
            this.selectionFalse = selectionFalse;
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(boolean isTrue) {

            if (isTrue)
                countIfTrue++;
            else
                countIfFalse++;
        }

        public void incrementCount(int counter) {
            countAll += counter;
        }

        @Override
        public Market generateMarket() {
            /*
             * don't generate market if it was flagged as being not wanted given match state e.g. some pre-match only or
             * in-play only
             */
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);

            market.setLineId("");
            market.setIsValid(countAll > 0);
            if (market.isValid()) {
                double prob = GCMath.round(((double) countIfTrue) / countAll, PROBS_DECIMAL_PLACES);
                double prob2 = GCMath.round(((double) countIfFalse) / countAll, PROBS_DECIMAL_PLACES);
                market.put(selectionTrue, prob);
                market.put(selectionFalse, prob2);
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            countIfTrue += ((TwoWayPlusStatistic) statistic).getCountIfTrue();
            countIfFalse += ((TwoWayPlusStatistic) statistic).getCountIfFalse();
            countAll += ((TwoWayPlusStatistic) statistic).getCountAll();
        }

        @Override
        public void reset() {
            countIfTrue = 0;
            countIfFalse = 0;
            countAll = 0;
        }
    }

    /**
     * A multi-way statistic, takes summed prob greater than 1
     * 
     * @author Jin
     * 
     */
    public class NWayStatistic2 extends Statistic {

        private int[] counts;
        private int noTrials;

        protected int getCount(int i) {
            return counts[i];
        }

        protected int getTotalCount() {
            return noTrials;
        }

        private String[] selections;

        /**
         * generates a market with N possible outcomes. - e.g. possibility of 2,3,4 or 5 sets played in a tennis match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selections - the text description associated with each of the possible N outcomes. The length of the
         *        selections array defines N
         * 
         */
        public NWayStatistic2(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        String[] selections) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.selections = new String[selections.length];
            this.counts = new int[selections.length];
            for (int i = 0; i < selections.length; i++) {
                this.selections[i] = selections[i];
            }
            reset();
        }

        /**
         * generates a market with N possible outcomes. - e.g. possibility of 2,3,4 or 5 sets played in a tennis match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selections - the text description associated with each of the possible N outcomes. The length of the
         *        selections array defines N
         * 
         */
        public NWayStatistic2(String key, String description, MarketGroup marketGroup, Boolean isValidGivenMatchState,
                        String sequenceId, String[] selections) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.selections = new String[selections.length];
            this.counts = new int[selections.length];
            for (int i = 0; i < selections.length; i++) {
                this.selections[i] = selections[i];
            }
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param i The index of the count to be incremented - index into the selections[] array supplied when the
         *        Statistic was created
         */
        public void increment(int i) {
            if (i >= counts.length) {
                String err = String.format("max count exceeded for market %s.  count = %d", key, i);
                throw new IllegalArgumentException(err);
            }
            counts[i]++;
        }

        public void incrementNoTrials() {
            noTrials++;
        }


        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);
            market.setLineId("");
            market.setIsValid(noTrials > 0);
            if (market.isValid()) {
                double x;
                for (int i = 0; i < counts.length; i++) {
                    x = GCMath.round(((double) counts[i]) / noTrials, PROBS_DECIMAL_PLACES);
                    if (allowGenerateAllSelection)
                        market.put(selections[i], x);
                    else if (x > 0.001)
                        market.put(selections[i], x);
                }
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < counts.length; i++)
                counts[i] += ((NWayStatistic2) statistic).getCount(i);

            noTrials += ((NWayStatistic2) statistic).getTotalCount();
        }

        @Override
        public void reset() {
            for (int i = 0; i < counts.length; i++)
                counts[i] = 0;
            noTrials = 0;
        }
    }

    /**
     * A three way statistic - usually "A"/"B"/"Neither"
     * 
     * @author Geoff
     * 
     */
    public class ThreeWayStatistic extends Statistic {

        private int countA;
        private int countB;
        private int countNeither;

        protected int getCountA() {
            return countA;
        }

        protected int getCountB() {
            return countB;
        }

        protected int getCountNeither() {
            return countNeither;
        }

        private String selectionA;

        private String selectionB;
        private String selectionNeither;

        /**
         * Holds a statistic with three outcomes, e.g. win/lose/draw
         *
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionA
         * @param selectionB
         * @param selectionNeither
         */
        public ThreeWayStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        String selectionA, String selectionB, String selectionNeither) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.selectionA = selectionA;
            this.selectionB = selectionB;
            this.selectionNeither = selectionNeither;
            reset();
        }

        /**
         * Holds a statistic with three outcomes, e.g. win/lose/draw
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selectionA
         * @param selectionB
         * @param selectionNeither
         */
        public ThreeWayStatistic(String key, String description, MarketGroup marketGroup,
                        Boolean isValidGivenMatchState, String sequenceId, String selectionA, String selectionB,
                        String selectionNeither) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.selectionA = selectionA;
            this.selectionB = selectionB;
            this.selectionNeither = selectionNeither;
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(TeamId id) {
            switch (id) {
                case A:
                    countA++;
                    break;
                case B:
                    countB++;
                    break;
                case UNKNOWN:
                    countNeither++;
                    break;
            }
        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);
            market.setLineId("");
            int n = countA + countB + countNeither;
            market.setIsValid(n > 0);
            if (market.isValid()) {
                market.put(selectionA, GCMath.round(((double) countA) / n, PROBS_DECIMAL_PLACES));
                market.put(selectionB, GCMath.round(((double) countB) / n, PROBS_DECIMAL_PLACES));
                market.put(selectionNeither, GCMath.round(((double) countNeither) / n, PROBS_DECIMAL_PLACES));
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            countA += ((ThreeWayStatistic) statistic).getCountA();
            countB += ((ThreeWayStatistic) statistic).getCountB();
            countNeither += ((ThreeWayStatistic) statistic).getCountNeither();
        }

        @Override
        public void reset() {
            countA = 0;
            countB = 0;
            countNeither = 0;
        }
    }

    /**
     * A multi-way statistic
     * 
     * @author Geoff
     * 
     */
    public class NWayStatistic extends Statistic {

        private int[] counts;

        protected int getCount(int i) {
            return counts[i];
        }

        private String[] selections;

        /**
         * generates a market with N possible outcomes. - e.g. possibility of 2,3,4 or 5 sets played in a tennis match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selections - the text description associated with each of the possible N outcomes. The length of the
         *        selections array defines N
         * 
         */
        public NWayStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        String[] selections) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.selections = new String[selections.length];
            this.counts = new int[selections.length];
            for (int i = 0; i < selections.length; i++) {
                this.selections[i] = selections[i];
            }
            reset();
        }

        /**
         * generates a market with N possible outcomes. - e.g. possibility of 2,3,4 or 5 sets played in a tennis match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param selections - the text description associated with each of the possible N outcomes. The length of the
         *        selections array defines N
         * 
         */
        public NWayStatistic(String key, String description, MarketGroup marketGroup, Boolean isValidGivenMatchState,
                        String sequenceId, String[] selections) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.selections = new String[selections.length];
            this.counts = new int[selections.length];
            for (int i = 0; i < selections.length; i++) {
                this.selections[i] = selections[i];
            }
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param i The index of the count to be incremented - index into the selections[] array supplied when the
         *        Statistic was created
         */
        public void increment(int i) {
            if (i >= counts.length) {
                String err = String.format("max count exceeded for market %s.  count = %d", key, i);
                throw new IllegalArgumentException(err);
            }
            counts[i]++;

        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);
            market.setLineId("");
            int n = 0;
            for (int i = 0; i < counts.length; i++)
                n += counts[i];
            market.setIsValid(n > 0);
            if (market.isValid()) {
                double x;
                for (int i = 0; i < counts.length; i++) {
                    x = GCMath.round(((double) counts[i]) / n, PROBS_DECIMAL_PLACES);
                    if (allowGenerateAllSelection)
                        market.put(selections[i], x);
                    else if (x > 0.001)
                        market.put(selections[i], x);
                }
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < counts.length; i++)
                counts[i] += ((NWayStatistic) statistic).getCount(i);
        }

        @Override
        public void reset() {
            for (int i = 0; i < counts.length; i++)
                counts[i] = 0;
        }
    }

    /**
     * correct score - e.g. 3-0
     * 
     * @author Geoff
     * 
     */
    public class CorrectScoreStatistic extends Statistic {

        private int[][] count;
        private int totalCount;
        private int overflowCount;
        private String correctScoreDisplayExternal = "";

        protected int getCount(int i, int j) {
            return count[i][j];
        }

        protected int getTotalCount() {
            return totalCount;
        }

        protected int getOverflowCount() {
            return overflowCount;
        }

        /**
         * generates a correct score market - e.g. prob of A winning 3-0 in a best of 5 match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxScore The max score either player is expected to be able to reach. In some sports there is no hard
         *        maximum, e.g. #goals in a football match. In this case set maxScore to be high enough so that
         *        probability of exceeding that score is less than 0.5%. If in doubt err on the high side. If the 0.5%
         *        limit is breached the generateMarket method will generate an IllegalArgumentException
         */
        public CorrectScoreStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        int maxScore) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            count = new int[maxScore + 1][maxScore + 1];
            correctScoreDisplayExternal = "";
            reset();
        }

        public CorrectScoreStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        int maxScore, String externalName) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            count = new int[maxScore + 1][maxScore + 1];
            correctScoreDisplayExternal = externalName;
            reset();
        }

        /**
         * generates a correct score market - e.g. prob of A winning 3-0 in a best of 5 match
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxScore The max score either player is expected to be able to reach. In some sports there is no hard
         *        maximum, e.g. #goals in a football match. In this case set maxScore to be high enough so that
         *        probability of exceeding that score is less than 0.5%. If in doubt err on the high side. If the 0.5%
         *        limit is breached the generateMarket method will generate an IllegalArgumentException
         */
        public CorrectScoreStatistic(String key, String description, MarketGroup marketGroup,
                        Boolean isValidGivenMatchState, String sequenceId, int maxScore) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            count = new int[maxScore + 1][maxScore + 1];
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(int scoreA, int scoreB) {
            /*
             * if (scoreA>count.length || scoreB > count.length) scoreA = 1;
             */
            if (scoreA >= count.length || scoreB >= count.length)
                overflowCount++;
            else {
                count[scoreA][scoreB]++;
                totalCount++;
            }
        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.GENERAL, marketGroup, key, sequenceId, description);
            market.setLineId("");
            // Add a fix to "few simulations" market that total Count has to be
            // more than 200
            market.setIsValid(totalCount > simulationLimit);

            if (market.isValid()) {
                double errRate = (double) overflowCount / (double) totalCount;
                if (errRate > 0.005) {
                    String err = String.format("maxScore set too low for market %s.  errRate %.3f exceeds 0.005", key,
                                    errRate);
                    throw new IllegalArgumentException(err);
                }
                for (int i = 0; i < count.length; i++)
                    for (int j = 0; j < count.length; j++)
                        if (count[i][j] > 0) {
                            String sName;
                            if (correctScoreDisplayHasTeamId) {
                                if (i > j)
                                    sName = correctScoreDisplayExternal + "A " + i + "-" + j;
                                else if (i < j)
                                    sName = correctScoreDisplayExternal + "B " + j + "-" + i;
                                else
                                    sName = j + "-" + i;
                            } else
                                sName = i + "-" + j;
                            double prob = GCMath.round(((double) count[i][j]) / totalCount, PROBS_DECIMAL_PLACES);
                            if (allowGenerateAllSelection)
                                market.put(sName, prob);
                            else if (prob > correctScoreLimit)
                                market.put(sName, prob);
                        }
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < count.length; i++) {
                for (int j = 0; j < count.length; j++) {
                    count[i][j] += ((CorrectScoreStatistic) statistic).getCount(i, j);
                }
            }
            totalCount += ((CorrectScoreStatistic) statistic).getTotalCount();
            overflowCount += ((CorrectScoreStatistic) statistic).getOverflowCount();
        }

        @Override
        public void reset() {
            for (int i = 0; i < count.length; i++) {
                for (int j = 0; j < count.length; j++) {
                    count[i][j] = 0;
                }
            }
            totalCount = 0;
            overflowCount = 0;
        }
    }

    /**
     * total market - e.g. over/under x.5
     * 
     * @author Geoff
     * 
     */
    public class TotalStatistic extends Statistic {

        int maxNoElements;
        int count[];
        int totalCount;
        int overflowCount;

        protected int getCount(int i) {
            return count[i];
        }

        protected int getTotalCount() {
            return totalCount;
        }

        protected int getOverflowCount() {
            return overflowCount;
        }

        /**
         * Generates an over/under type market.
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements the max count that can occur during the simulation. e.g. for no games in a tie break
         *        tennis set maxNo elements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         */
        public TotalStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        int maxNoElements) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.maxNoElements = maxNoElements;
            count = new int[maxNoElements + 1];
            reset();
        }

        /**
         * Generates an over/under type market.
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements the max count that can occur during the simulation. e.g. for no games in a tie break
         *        tennis set maxNo elements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         */
        public TotalStatistic(String key, String description, MarketGroup marketGroup, Boolean isValidGivenMatchState,
                        String sequenceId, int maxNoElements) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.maxNoElements = maxNoElements;
            count = new int[maxNoElements + 1];
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(int n) {

            if (n >= count.length)
                overflowCount++;
            else {
                count[n]++;
                totalCount++;
            }
        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.OVUN, marketGroup, key, sequenceId, description);
            market.setLineId("");
            market.setIsValid(totalCount > 0);
            if (market.isValid()) {
                double errRate = (double) overflowCount / (double) totalCount;
                if (errRate > 0.005) {
                    String err = String.format("maxScore set too low for market %s.  errRate %.3f exceeds 0.005", key,
                                    errRate);
                    throw new IllegalArgumentException(err);
                }
                OverUnderMarket result = new OverUnderMarket(count, totalCount);
                double lineId = GCMath.round(result.lineIdentifier + .5, 1);
                String lineStr = String.format("%.1f", lineId);
                market.setLineId(lineStr);
                market.setSelectionNameOverOrA("Over " + lineId);
                market.setSelectionNameUnderOrB("Under " + lineId);
                market.put("Over", result.probOver);
                market.put("Under", result.probUnder);
                market.setLineBase(result.trimmedBase);
                market.setLineProbs(result.trimmedProbs);
            }
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < count.length; i++)
                count[i] += ((TotalStatistic) statistic).getCount(i);
            totalCount += ((TotalStatistic) statistic).getTotalCount();
            overflowCount += ((TotalStatistic) statistic).getOverflowCount();
        }

        @Override
        public void reset() {
            for (int i = 0; i < count.length; i++)
                count[i] = 0;
            totalCount = 0;
            overflowCount = 0;
        }
    }

    public class HandicapStatistic extends Statistic {

        int minBias;
        int count[];
        int totalCount;
        int overflowCount;
        String playerAName;
        String playerBName;

        protected int getCount(int i) {
            return count[i];
        }

        protected int getTotalCount() {
            return totalCount;
        }

        protected int getOverflowCount() {
            return overflowCount;
        }

        /**
         * generates a handicap type market, e.g. A(-4.5), B(+4.5)
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements - the max no if events that can occur in whatever is being counted - e.g. for a tie
         *        break tennis set maxNoelements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         * @param minBias +ve no which indicates what the max difference between the two player scores can be. e.g. for
         *        tie break tennis match, the biggest difference in score is 6-0 so minBias would be set to 6
         */
        public HandicapStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        int maxNoElements) {
            super(key, description, MarketGroup.NOT_SPECIFIED, isValidGivenMatchState, sequenceId);
            this.minBias = maxNoElements / 2 + 1;
            this.playerAName = "AH";
            this.playerBName = "BH";
            count = new int[maxNoElements + 3];
            reset();
        }

        /**
         * generates a handicap type market, e.g. A(-4.5), B(+4.5)
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements - the max no if events that can occur in whatever is being counted - e.g. for a tie
         *        break tennis set maxNoelements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         * @param minBias +ve no which indicates what the max difference between the two player scores can be. e.g. for
         *        tie break tennis match, the biggest difference in score is 6-0 so minBias would be set to 6
         */
        public HandicapStatistic(String key, String description, MarketGroup marketGroup,
                        Boolean isValidGivenMatchState, String sequenceId, int maxNoElements) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.minBias = maxNoElements / 2 + 1;
            this.playerAName = "AH";
            this.playerBName = "BH";
            count = new int[maxNoElements + 3];
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(int n) {
            if (n + minBias >= count.length || n + minBias < 0)
                overflowCount++;
            else {
                count[n + minBias]++;
                totalCount++;
            }

        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.HCAP, marketGroup, key, sequenceId, description);
            market.setIsValid(true);
            double errRate = (double) overflowCount / (double) totalCount;
            if (errRate > 0.005) {
                String err = String.format("maxScore set too low for market %s.  errRate %.3f exceeds 0.005", key,
                                errRate);
                throw new IllegalArgumentException(err);
            } else if (totalCount == 0) {
                String err = String.format("totalCount for market %s. is 0 ", key, errRate);
                throw new IllegalArgumentException(err);
            }
            OverUnderMarket result = new OverUnderMarket(count, totalCount);
            double lineId = GCMath.round(result.lineIdentifier - minBias + .5, 1);
            lineId = -lineId;
            String lineStr = String.format("%.1f", lineId);
            market.setLineId(lineStr);

            String lineIdA, lineIdB;
            // Updated by Robert
            if (lineId < 0) {
                lineIdA = playerAName + " (" + lineId + ")";
                lineIdB = playerBName + " (+" + (-lineId) + ")";
            } else {
                lineIdA = playerAName + " (+" + lineId + ")";
                lineIdB = playerBName + " (" + (-lineId) + ")";
            }
            market.setSelectionNameOverOrA(lineIdA);
            market.setSelectionNameUnderOrB(lineIdB);

            market.put("AH", result.probOver);
            market.put("BH", result.probUnder);
            market.setLineBase(result.trimmedBase - minBias);
            market.setLineProbs(result.trimmedProbs);
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < count.length; i++)
                count[i] += ((HandicapStatistic) statistic).getCount(i);
            totalCount += ((HandicapStatistic) statistic).getTotalCount();
            overflowCount += ((HandicapStatistic) statistic).getOverflowCount();

        }

        @Override
        public void reset() {
            for (int i = 0; i < count.length; i++)
                count[i] = 0;
            totalCount = 0;
            overflowCount = 0;
        }

    }

    public class EuroHandicapStatistic extends Statistic {

        int minBias;
        int count[];
        int totalCount;
        int overflowCount;
        String playerAName;
        String playerBName;

        protected int getCount(int i) {
            return count[i];
        }

        protected int getTotalCount() {
            return totalCount;
        }

        protected int getOverflowCount() {
            return overflowCount;
        }

        /**
         * generates a euro handicap type market, e.g. A(-4.5), B(+4.5)
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements - the max no if events that can occur in whatever is being counted - e.g. for a tie
         *        break tennis set maxNoelements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         * @param minBias +ve no which indicates what the max difference between the two player scores can be. e.g. for
         *        tie break tennis match, the biggest difference in score is 6-0 so minBias would be set to 6
         */
        public EuroHandicapStatistic(String key, String description, Boolean isValidGivenMatchState, String sequenceId,
                        int maxNoElements) {
            super(key, description, MarketGroup.GOALS, isValidGivenMatchState, sequenceId);
            this.minBias = maxNoElements / 2 + 1;
            this.playerAName = "AH";
            this.playerBName = "BH";
            count = new int[maxNoElements + 3];
            reset();
        }

        /**
         * generates a euro handicap type market, e.g. A(-4.5), B(+4.5)
         * 
         * @param key Unique market key - also called "type"
         * @param description Text description associated with this market
         * @param marketGroup group to which this market belongs
         * @param isValidGivenMatchState If false then statistic is still created but generateMarket will return null
         * @param sequenceId For "lazy" markets the unique id that can be used to identify this specific market for
         *        later use by the ResultMarket process. e.g. for "next goal" might be "G3". In tennis might be "S1.2.3"
         *        for 3rd point of second game of first set.
         * @param maxNoElements - the max no if events that can occur in whatever is being counted - e.g. for a tie
         *        break tennis set maxNoelements would be 13. In some sports there is no hard maximum, e.g. #goals in a
         *        football match. In this case set maxScore to be high enough so that probability of exceeding that
         *        score is less than 0.5%. If in doubt err on the high side. If the 0.5% limit is breached the
         *        generateMarket method will generate an IllegalArgumentException
         * @param minBias +ve no which indicates what the max difference between the two player scores can be. e.g. for
         *        tie break tennis match, the biggest difference in score is 6-0 so minBias would be set to 6
         */
        public EuroHandicapStatistic(String key, String description, MarketGroup marketGroup,
                        Boolean isValidGivenMatchState, String sequenceId, int maxNoElements) {
            super(key, description, marketGroup, isValidGivenMatchState, sequenceId);
            this.minBias = maxNoElements / 2 + 1;
            this.playerAName = "AH";
            this.playerBName = "BH";
            count = new int[maxNoElements + 3];
            reset();
        }

        /**
         * updates the statistic with a result
         * 
         * @param isTrue
         */
        public void increment(int n) {
            if (n + minBias >= count.length || n + minBias < 0)
                overflowCount++;
            else {
                count[n + minBias]++;
                totalCount++;
            }
        }

        @Override
        public Market generateMarket() {
            if (!isValidGivenMatchState)
                return null;
            Market market = new Market(MarketCategory.HCAPEU, marketGroup, key, sequenceId, description);
            market.setIsValid(true);
            double errRate = (double) overflowCount / (double) totalCount;
            if (errRate > 0.005) {
                String err = String.format("maxScore set too low for market %s.  errRate %.3f exceeds 0.005", key,
                                errRate);
                throw new IllegalArgumentException(err);
            }
            OverDrawUnderMarket result = new OverDrawUnderMarket(count, totalCount, minBias);
            double lineId = GCMath.round(result.lineIdentifier - minBias, 1);
            lineId = -lineId;
            String lineStr = String.format("%.1f", lineId);
            market.setLineId(lineStr);

            String lineIdA, lineIdB, lineIdD;
            // Updated by Robert
            if (lineId < 0) {
                lineIdA = playerAName + " (" + lineId + ")";
                lineIdB = playerBName + " (+" + (-lineId) + ")";
                lineIdD = "Draw" + lineId;
            } else {
                lineIdA = playerAName + " (+" + lineId + ")";
                lineIdB = playerBName + " (" + (-lineId) + ")";
                lineIdD = "Draw" + " (" + (lineId) + ")";
            }
            market.setSelectionNameOverOrA(lineIdA);
            market.setSelectionNameUnderOrB(lineIdB);
            market.setSelectionNameDrawOrD(lineIdD);

            market.put("AH", GCMath.round(result.probOver, PROBS_DECIMAL_PLACES));
            market.put("BH", GCMath.round(result.probUnder, PROBS_DECIMAL_PLACES));
            market.put("DH", GCMath.round(result.probDraw, PROBS_DECIMAL_PLACES));
            market.setLineBase(result.trimmedBase - minBias);
            market.setLineProbs(result.trimmedProbs);
            return market;
        }

        @Override
        public void consolidate(Statistic statistic) {
            for (int i = 0; i < count.length; i++)
                count[i] += ((EuroHandicapStatistic) statistic).getCount(i);
            totalCount += ((EuroHandicapStatistic) statistic).getTotalCount();
            overflowCount += ((EuroHandicapStatistic) statistic).getOverflowCount();

        }

        @Override
        public void reset() {
            for (int i = 0; i < count.length; i++)
                count[i] = 0;
            totalCount = 0;
            overflowCount = 0;
        }

    }

    private class OverUnderMarket {
        public int lineIdentifier;
        public double probOver;
        public double probUnder;
        public int trimmedBase;
        public double[] trimmedProbs; //

        public OverUnderMarket(int[] array, int total) {

            // find the row which is going to most closely match a probability
            // of 0.5
            double threshold = (double) total / 2;
            int k = -1;
            int lastK = -1;
            int runningTotal = 0;
            int lastRunningTotal = 0;
            double diffToThreshold = threshold;
            double lastDiffToThreshold = threshold;
            while (runningTotal < threshold) {
                lastK = k;
                lastRunningTotal = runningTotal;
                lastDiffToThreshold = diffToThreshold;
                k++;
                runningTotal += array[k];
                diffToThreshold = Math.abs((double) runningTotal - threshold);
            }
            if (lastDiffToThreshold < diffToThreshold) {
                k = lastK;
                runningTotal = lastRunningTotal;
            }
            lineIdentifier = k;
            probUnder = GCMath.round((double) runningTotal / (double) total, PROBS_DECIMAL_PLACES);
            probOver = GCMath.round(1 - probUnder, PROBS_DECIMAL_PLACES);

            /*
             * calculated the trimmed probs - basically cumulative probability array, discarding those outside alpha
             */
            int alpha = (int) (0.002 * (double) total);

            int lBound = -1;
            int sumCount = 0;
            boolean foundBound = false;
            while (!foundBound) {
                lBound++;
                sumCount += array[lBound];
                foundBound = sumCount > alpha;
            }
            int uBound = array.length;
            sumCount = 0;
            foundBound = false;
            while (!foundBound) {
                uBound--;
                sumCount += array[uBound];
                foundBound = sumCount > alpha;
            }
            trimmedProbs = new double[uBound - lBound + 1];
            double dTotal = (double) total;
            trimmedProbs[0] = ((double) array[lBound]) / dTotal;
            for (int i = lBound + 1; i <= uBound; i++) {
                trimmedProbs[i - lBound] = trimmedProbs[i - lBound - 1] + ((double) array[i]) / dTotal;
            }
            trimmedBase = lBound;
            for (int i = 0; i < trimmedProbs.length; i++)
                trimmedProbs[i] = GCMath.round(trimmedProbs[i], PROBS_DECIMAL_PLACES);
        }
    }

    private class OverDrawUnderMarket {
        public int lineIdentifier;
        public double probOver;
        public double probUnder;
        public double probDraw;
        public int trimmedBase;
        public double[] trimmedProbs; //

        public OverDrawUnderMarket(int[] array, int total, int minBias) {
            // find the row which is going to most closely match a probability
            // of 0.5
            double threshold = (double) total / 2;
            int k = -1;
            int runningTotal = 0;
            int lastRunningTotal = 0;
            while (runningTotal < threshold) {
                lastRunningTotal = runningTotal;
                k++;
                runningTotal += array[k];
            }

            if (k == minBias) {
                lastRunningTotal = runningTotal;
                k++;
                runningTotal += array[k];
            }

            // k is the number that make runningtotal first time cross the
            // threshold

            lineIdentifier = k;
            probUnder = GCMath.round((double) lastRunningTotal / (double) total, PROBS_DECIMAL_PLACES);
            probDraw = GCMath.round((double) (runningTotal - lastRunningTotal) / (double) total, PROBS_DECIMAL_PLACES);
            probOver = 1 - probUnder - probDraw;

            /*
             * calculated the trimmed probs - basically cumulative probability array, discarding those outside alpha
             */
            int alpha = (int) (0.002 * (double) total);

            int lBound = -1;
            int sumCount = 0;
            boolean foundBound = false;
            while (!foundBound) {
                lBound++;
                sumCount += array[lBound];
                foundBound = sumCount > alpha;
            }
            int uBound = array.length;
            sumCount = 0;
            foundBound = false;
            while (!foundBound) {
                uBound--;
                sumCount += array[uBound];
                foundBound = sumCount > alpha;
            }
            trimmedProbs = new double[uBound - lBound + 1];
            double dTotal = (double) total;
            trimmedProbs[0] = ((double) array[lBound]) / dTotal;
            for (int i = lBound + 1; i <= uBound; i++) {
                trimmedProbs[i - lBound] = trimmedProbs[i - lBound - 1] + ((double) array[i]) / dTotal;
            }
            trimmedBase = lBound;
            for (int i = 0; i < trimmedProbs.length; i++)
                trimmedProbs[i] = GCMath.round(trimmedProbs[i], PROBS_DECIMAL_PLACES);
        }
    }

    /**
     * Should be overriden by any sport for which we can generate some of the markets from the set of markets already
     * created (e.g. by Monte Carlo methods), the current match state and the current match params
     * 
     * @param markets
     * @param matchState
     * @param matchParams
     */
    public void addDerivedMarkets(Markets markets, MatchState matchState, MatchParams matchParams) {

    }

}
